# PCCP Coding Test for '24

- PCCP (코딩전문역량인증시험 일정)

  - ![](img/2024-01-13-01-42-42.png)
  - Lv3의 문제를 문제없이 풀면 가뿐하다는데,
  - '24.2/18 시험 접수해보는 것으로, 또는 3월 시험 일정
  - PCCP 시험을 보기 전에, 프로그래머스에서 제공하는 [스킬체크(난이도별)](https://school.programmers.co.kr/skill_checks)를 응시하면 좋은 준비가 될 듯

- 맥북 단축키 익히기

  - 코드 러너 단축키: `ctrl+opt+N`
  - 스크린샷: `shift+cmd+4`
  - 마크다운 이미지 붙여넣기: `opt+cmd+v`
  - 터미널 창 토글: ctrl+` (근데 이거 한글입력 상태일 땐 안되고, 영어입력 상태일때만 됨)

- 평일: 손코딩, 퇴근 후 1~3문제
- 주말: 최소 5문제 풀기
  - 1주일에 25문제
  - ![](img/2024-01-21-21-12-29.png)
  - ![](img/2024-01-21-21-12-55.png)

---

## 2. [인프런 강의2](https://www.inflearn.com/course/10%EC%A3%BC%EC%99%84%EC%84%B1-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%81%B0%EB%8F%8C/dashboard)

1. [알고리즘 수업자료](./material/알고리즘교안.pdf)
2. [문제 및 해설](./material/알고리즘+문제해설.pdf)

### 2-1. 기본

1. 재귀함수(recursion)

- ![](img/2024-01-21-00-04-58.png)
- 첫 문단에는 반드시 기저사례 (종료조건)을 포함해야 한다,
- 두번째 문단은 재귀호출을 하는 라인이 위치
  - 사이클이 있다면 쓰면 안된다. (종료가 안됨)
- 마지막은 최종적으로 return 하고 싶은 값이 있다면 위치할 것
  - 반복문으로 될 것 같으면 반복문으로 작성하는 것이 낫다.

2. 순열(permutation)과 조합(combination)

- 순열(permutation)은 순서가 상관있는 나열

  - `std::next_permutation(begin(), end()) 오름차순으로 만들어줌`
  - STL을 쓸 때, 배열은 정렬이 되어 있어야 함 (오름차순에 맞게)
  - `std::prev_permutation(begin(), end()) 내림차순으로 만들어줌`
  - [직접 구현은 재귀함수로 구현](./2_basic/permutation_self.cpp)

- 조합(combination)은 순서가 상관없는 나열
  - [combination 직접구현: 외워라 무조건](./2_basic/combination_self.cpp)
  - [3개를 뽑는 것이면 for문 3개로도 풀 수 있다](./2_basic/combination_for.cpp)

3. split() 함수

- "aaa bbb ccc" => {"aaa", "bbb", "ccc"}
  - STL에 `split`는 제공하지 않는다. 만들면 됨
  ```c++
  while ((pos = input.find(delimeter)) != string::npos){
      token = input.substr(0, pos); // token에 찾은 부분을 넣어주고
      ret.push_back(token);
      input.erase(0, pos + delimeter.length()); // delimeter를 포함해서 지운다
  }
  ret.push_back(input); // 마지막 나머지도 ret 에 넣어줘야지
  ```

4. 메모리와 포인터

- 메모리는 1바이트의 셀들로 이루어져있고, 각 셀들은 고유한 주소를 갖는다.
  - int는 4바이트니까, int를 선언하면, 4개의 셀을 예약하게 된다.
- 포인터는 메모리의 주소를 가리키는 타입 `Node* p`
  - 포인터의 크기 (sizeof(p) = 8 <64비트 운영체제라면>)는 운영체제에 따라 다름
- 역참조(dereference)
  - 포인터 주소가 가리키는 value를 풀어헤친다는 의미지
  ```c++
  string a = "adv" // define & declaration
  string *b = &a; // point
  *b = "ggg" ; // de-reference
  ```
- 배열의 포인터

  - 배열의 이름 = 주소값 (=Array to Pointer decay)

  ```c++
  int a[N];
  int *c = a; // array to pointer decay, a 배열의 크기는 날라갔지만 이렇게 나타낼 수 있다는 것, 이렇게 될 경우 a의 첫번째 주소가 배열의 주소로 binding된다.

  int* c = &a[0]; // 위와 같은 것임
  ```

5. 중복된 요소 제거

- `{1,1,2,2,3,3}`
- 가장 간단하게 구현하는 방법은 map 구조를 이용해서 map[1] = true; [이런식으로](./2_basic/map_for_unique.cpp)
- STL에 구현되어 있는 함수 [`unique()`](./2_basic/unique.cpp)
  - `V.erase(unique(V.begin(), V.end()), V.end());`

### 2-2. 1주차: 시간복잡도, 빅오표기법, 공간복잡도, 누적합, 구현

- 시간복잡도: 어떠한 알고리즘이 주어진 입력크기를 기반으로 어떠한 로직이 몇번 반복되었는가

  - 빅오표기법(Big-Order): e.g. $O(n^2)$
    - 복잡도에 가장 영향을 많이 끼치는 항의 상수인자를 빼고 나머지 항을 없애서 복잡도를 나타내는 표기법
    - ![](img/2024-01-21-21-37-51.png)
  - 재귀함수의 시간복잡도는: `main Logic`복잡도 + `재귀함수`총 호출 횟수
  - 문제에서 풀라고 하면 `count`를 직접 찍어보고 유추해보는 식으로

- 공간복잡도: 입력 크기에 대해 어떠한 알고리즘이 실행되는데 필요한 변수(메모리) 공간의 양
    - 문제를 푼다고 하면, 문제에 주어진 `최대범위`, `메모리제한`(512mb) -> 512,000,000 -> int 배열이라면 `/4`한 만큼 쓸 수 있다는 의미

- 누적합: `prefixSum`
    - ![](img/2024-01-21-22-40-30.png)
    - 문제 유형: 구간 합 구하기(`구간쿼리`) -> 누적합을 떠올려야함 또는 펜윅트리(`동적배열인 경우`)

- 구현: 말 그대로 문제 그대로 구현하면 됨
    - 예를 들어, 배열을 회전(`void reverse(v.begin(), v.end())`하라 스택에 넣어라 등.

- 카운팅Star: 어떤 요소가 나온 횟수를 세기 `맵 또는 배열` 자료구조로 구현
  - Map: string 요소일 경우 / sparse 한 요소일 경우
    - 알파벳도 아스키코드로 이루어져있으니까 배열이 나음
      - `v[input[i] - 'a'] += 1;`
    - 아스키코드 2개만 외워: "A: 65 / a:97" , 총 알파벳은 25개임
  - 배열: integer 요소일 경우

- 백준 풀기
  - [boj2309](./2_1주차/boj2309.cpp) // 1-A
  - [boj10808](./2_1주차/boj10808.cpp) // 1-B
  - [boj2979 나쁘게 푼 예시](./2_1주차/boj2979_bad.cpp)
    - 구현문제처럼 긴 코드로 풀었는데..., 아래 처럼 푸는게 시간복잡도는 같긴 하지만 라인수가 적어 더 좋은 코드입니다.
    - [boj2979](./2_1주차/boj2979.cpp) // 1-C
  - [boj10988](./2_1주차/boj10988.cpp) // 1-D
  - [boj1159](./2_1주차/boj1159.cpp) // 1-E
    - 참고삼아, 아스키코드로 A는 65 , a는 97에 대응된다. 알파벳은 26개이다.
  - [boj11655](./2_1주차/boj11655.cpp) // 1-F
    - `getline(cin, s);`
  - [boj9996](./2_1주차/boj9996.cpp) // 1-G
    - 흠... 문제를 정확히 파악 못해서 왜맞틀만 반복하고 못 풀었음
    - string parsing 하는 것을 외우자
      ```c++
      int pos = pattern.find("*");
      string pre, suf;
      pre = pattern.substr(0,pos); // 구간 자르기 (begin_pos, end_pos)
      suf = pattern.substr(pos+1); // pos+1 하나의 인자만을 넘겨준 상황에선 pattern 문자열의 끝까지 자르게 된다.
      ```
  - [boj2559](./2_1주차/boj2559.cpp) // 1-H
    - DP로 풀었는데, 구간합으로 푸는것도 좋다.
    - 시간복잡도는 O(N)으로 동일함
  - [boj1620](./2_1주차/boj1620.cpp) // 1-I
    - 혼자 못 풀었다...;
      1. 맵을 두개 써야 한다.
      왜냐면, pockets 를 하나 써서, int 가 나오면 pockets.begin() + number 로 찾아가려고 했는데,
      맵같은 경우는 array와 다르게 순서대로 저장되는 형태가 아니기 떄문에 그래선 안된다.
      2. atoi(s.c_str()) 을 통과할 경우 int가 아닌 것들은 0이 리턴된다.
      이를 통해 int인지 아닌지 구분할 수 있다.
  - [boj9375](./2_1주차/boj9375.cpp) // 1-J
    - 혼자 풀었더니, Timeout이 발생하였음
      - 모든 Combination을 직접 구한다음에 값을 계산하려고 하였음 [boj9375_timeout](./2_1주차/boj9375_timeout.cpp)
    - Timeout을 해소하려면 아이디어가 필요함
      - 선글라스 3종류, 헤드기어 2종류가 있다면, 문제에선 아무것도 안 입는것만을 제외하고 모든 경우의 수를 구하라고 했으니까
      - 선글라스 3+1(안입는) , 헤드기어 2+1(안입는) = 4 x 3 = 12 -1 (아무것도 안입는) 방식을 통해 구할 수 있다.
        - 아이디어가 필요한 문제였음
      - 경우의 수를 구하는 문제의 경우 `answer` 변수를 `long long`으로 선언하자
    
  - [boj1213](./2_1주차/boj1213.cpp) // 1-K
    - 타임아웃 STL을 이용해서 라인수를 짧게 해서 풀었는데.., 시간초과 뜬다.
    - 시간을 단축해서 풀어야하는 문제임 [boj1213_timeout](./2_1주차/boj1213_timeout.cpp)
    - 강의를 보니, 규칙을 파악해서 시간을 단축할 수 있는 방법으로 풀어야함
      - 그리디 알고리즘
        1. 홀수 알파벳이 2개 이상이면 팰린드롬을 만들 수 없다.
        2. 생성할 팰린드롬은 가장 알파벳이 큰 값부터 `mid`에 붙여 나가는 식으로 생성한다.
  - [boj1940](./2_1주차/boj1940.cpp) // 1-L
    - 처음 시도에서 오래 걸렸다.
    - 문제에서 분명히 2개만 고른다고 했는데도 나는, 고르는 재료의 개수는 상관없는지 알고,
      - 모든 조합, nC1, nC2, nC3, nC4 ... 순서로 조합을 찾아가며 조건을 만족하면
      - 해당 원소는 지우는 형태로 로직을 구현하려고 했다.
    - 그럴 필요가 없는 문제였다 ㅠㅠㅠ.. 문제좀 잘 읽어 꼼꼼하게
    - 2개를 뽑는 문제임을 알고 `recursively` 하게 combination을 구해서 조건을 만족하는지
      체크하는 코드를 구현했는데, 메모리 초과가 났다.
      - 이렇게 푸는게 아닌가 해서.. 강의를 들으니까.. combination을 2중 for문을 통해서 만들어내서
        메모리 초과는 없게 알고리즘을 만들었더라.
      - 외우자.. nC3 까지는 for문으로 구현하고 그보다 큰 경우에 recursive로 구하자.
      - [boj1940_메모리아웃](./2_1주차/boj1940_메모리아웃.cpp)
  - [boj3986](./2_1주차/boj3986.cpp) // 1-M
    - 이건 혼자 풀었다.
    - stack 자료구조를 이용하면 풀 수 있는 문제다.
    - 이런 `ABABAB..` 등의 순서를 갖는 문자열을 해결하는 문제를 만났을 때, 풀이가 떠오르지 않으면
      - 주어진 문자열을 뒤집어도 보고 90도 회전도 해보고 앞뒤로도 붙여보면서 종이에 써서 아이디어를 떠올려 봐라
    - 문제에서 만약에 `짝짓기 또는 폭발`이라는게 나오면 `stack`을 떠올려라
  
  - [boj1629](./2_1주차/boj1629.cpp) // 1-N
    - 굉장히 유명한 문제임
    - 분할정복 문제라는 힌트를 보고 (log2N)의 복잡도를 갖게끔 풀었다
    - 처음에는 for 문으로 접근해서 풀었는데, 당연히 시간초과고,,,
    - log2N 방식으로 푼 이후에도 틀렸다고 나왔는데, 문제에서 주어진 최대값 조건을 보고 풀어야한다.
      - 문제에서 변수의 최대값을 보면 32bit 자료형인데 꽤 큰 값이기 때문에 모든 연산에 `%C`를 해주어서 중간중간 mod 값을 계산해주면서 풀어야한다.
    - 모듈러 연산 (`곱하기 더하기에 대한 분배법칙이 성립한다.`)
      1. $(a+b)\%c = a\%c + b\%c$
        - 증명:
        $$
        a = q1*c + r1, b = q2*c + r2  이므로,
        ((q1+q2)*c+r1+r2)\%c
        = (r1+r2)\%c
        = r1\%c + r2\%c 
        = a\%c + b\%c 가 성립한다.
        $$
      2. $(a*b)\%c = a\%c * b\%c$
  - [boj4375](./2_1주차/boj4375.cpp) // 1-O
    - 혼자 못풀었음
    - 최대공약수가 자기 자신이 나오면, 그 말은 배수라는 뜻이니까,, 그렇게 되면 정답을 찾게되는거니까 gcd 알고리즘을 만들어서 해봣는데
      - 시간초과입니다.
      - 구현해놓고 생각해보니, 최대공약수 구하는거나 바로 `111%a==0` 확인하는거나 시간복잡도 측면에선 차이가 없을듯하네 [boj4375_timepout](./2_1주차/boj4375_timeout.cpp)
    - 최대공약수는 전혀 만들필요가 없었고요...
    - 모듈러 연산의 특성을 이용하는 문제였음
      - 아래 코드처럼 mod 값을 계속 증가시키게 되는데, 이 때 중간 연산인 `mod = (mod*10+1)%N` 해주는 방식으로 풀면된다.
        ```c++
        if (mod%N == 0){
          cout << i << "\n";
          break;
        }
        mod = (mod * 10 + 1)%N; // 모듈러 연산의 특성을 이용해서 중간계산을 계속 해주어도 된다.
        ```

### 2-3. 2주차: 그래프이론 DFS BFS

1. 그래프
- 그래프: 정점(vertex)와 간선(edge)로 이루어진 집합(세트)를 그래프라고 함
- 정점(Vertex)는 노드라고도 불림. 즉, 점
- 간선(Edge)는 정점을 잇는 선을 의미함
  - 단방향 간선도 있고, 양방향 간선도 있고,
  - 예를 들어 `u->v` (단방향 간선)
- 가중치: 정점(vertex)와 정점(vertex) 사이의 간선을 이동하는데 드는 비용
  1. in degree
    : 해당 정점으로 들어오는 간선의 개수
  2. out degree
    : 해당 정점을 나가는 간선의 개수
    ![](img/2024-01-27-23-32-30.png)

2. 트리 (그래프 구조에 속함)
- 트리: 자식노드와 부모노드로 이루어진 계층적 구조로 무방향 그래프의 일종이자 사이클이 없는 자료구조
  - 트리: `Edge의 수 = Vertex의 수 - 1`
  - 루트 노드: 트리의 처음(부모노드가 없는)
  - 리프 노드: 트리의 맨 마지막 (자식노드가 없는)
  - 트리가 여러개인 걸 forest 구조라고 함


3. 이진트리(`BT`)와 이진탐색트리(`BST`)
  - 이진 트리: 각각의 노드의 자식노드의 수가 2개 이하로 구성되어 있는 트리를 의미함
  ![](img/2024-01-28-19-02-47.png)
  3-1. 정 이진 트리 full binary tree: 자식 노드가 0 또는 2개인 이진트리
  3-2. 완전 이진 트리 compelte binary tree: 왼쪽에서 부터 채워져 있는 이진 트리, 마지막 레벨을 제외하고는 모든 레벨이 채워져 있음
  3-3. 변질 이진 트리 degenerate binary tree: 자식 노드가 하나 밖에 없는 이진 트리
  3-4. 포화 이진 트리 perfect binary tree: 모든 노드가 꽉 차 있는 이진 트리
  3-5. 균형 이진 트리 balanced binary tree: 모든 노드의 왼쪽 하위 트리와 오른쪽 하위트리의 높이 차이가 1이하인 트리, `map, set`을 구성하는 레드블랙트리는 균형 이진트리 중 하나임

  - 이진 탐색 트리: 이진 트리의 일종으로 노드의 오른쪽 하위 트리에는 노드의 값보다 큰값, 왼쪽 하위트리에는 노드의 값보다 작은값이 들어가 있는 트리
  ![](img/2024-01-28-19-10-32.png)
    - 탐색 시 시간 복잡도, 이진트리의 높이가 좌/우 균형 잡혀있지 않으면 최악의 경우에 탐색의 시간복잡도는 O(N). 따라서, 트리의 구조가 균형잡혀 있어야 탐색의 시간복잡도가 O(logN)이다.
    ![](img/2024-01-28-19-31-33.png)

4. 인접 정보 (adjacency matrix 또는 adjancency list)
  - 그래프로 이루어진 정보를 담고 있는, (인접해있다. 연결되어있다.)
  - 인접 행렬: 그래프에서 `정점과 간선의 관계를 나타내는 bool 타입의 정사각형 행렬`을 의미함
    ![](img/2024-01-28-19-42-27.png)
    - 만약, 자신에서 자신으로 이동할 수 있으면 (사이클이 있으면) a[i][i] = 1 이 된다.
    ```c++
    bool adj[4][4] = {
      {0,1,1,1},
      {1,0,1,0},
      {1,1,0,0},
      {1,0,0,0},
    };
    ```
    - 인접행렬을 이용한 그래프 순회 [예제](./2_2주차/adj_matrix.cpp)
  - 인접 그래프: 그래프에서 정점과 간선의 관계를 나타내는 연결리스트를 의미함(벡터 자료구조로도 구현 가능함, 시간복잡도 동일)
    - 정점마다, 연결되어 있는 노드를 나타내는 리스트를 만든다.
    ```c++
    vector<int> adj[4];
    adj[0] = {1, 2, 3};
    adj[1] = {0, 2};
    adj[2] = {0, 1};
    adj[3] = {0};
    ```
    - 인접리스트를 이용한 그래프 순회 [예제](./2_2주차/adj_list.cpp)


  - 인접행렬과 인접리스트의 차이: 무엇을 써야할까?
    1. 공간복잡도
      - 인접행렬은 sparse하게 인접정보를 포함하므로, 공간복잡도가 `O(V^2)`가 된다.
      - 인접리스트의 공간복잡도는 `O(V+E)`

    2. 시간복잡도: 간선(Edge) 한개 찾기
      - 인접행렬: `O(1)`
      - 인접리스트: `O(V)`
    
    3. 시간복잡도: 모든 간선 찾기
      - 인접행렬: `O(V^2)`
      - 인접리스트: `O(V+E)`

    4. 그래프가 희소할 때(Sparse)는 인접리스트, 조밀할 때는 인접행렬이 좋다.
      - 조밀할때(dense)는 인접행렬의 간선 하나를 찾는 시간복잡도가 좋기 때문에 인접행렬이 좋다.
      - 문제를 풀 땐 어떻게 선택할지..,
        - 보통은 sparse 한 그래프가 주어지기 때문에, 인접리스트로 푸는게 낫다.
        - 인접행렬이 주어지면, 그대로 인접행렬로 푸는게 낫고..,
    
  5. 맵과 방향벡터(direction vector)
  - 미로 찾기 문제에서는 2차원 그리드 형태의 맵 정보가 주어진다.
    - 미로라는 2차원 그리드를 인접한 그리드만 연결되어 있는 형태라고 볼 수 있다.
    - direction 방향 벡터를 통해 인접한 노드를 방문하기 위한 배열을 정의할 수 있다.
      ```c++
      int direction[4][4] = {
        {-1,  0}, // up
        { 1,  0}, // down
        { 0, -1}, // left
        { 0,  1}, //right
      };
      // 동서남북 뿐만 아니라 대각선방향으로 이동가능하다고 주어질 수도 있다.
      ```

  6. 연결된 컴포넌트 (connected componet)
  - ![](img/2024-01-28-21-45-23.png)
  - 연결된 컴포넌트(덩어리)를 찾는 문제: `flood fill`
    - DFS로 풀면된다.
    - [예제 코드](./2_2주차/maze.cpp)

  7. 깊이우선탐색(DFS, Depth First Search)
  -  DFS는 인접한 노드들을 재귀적으로 방문하는 알고리즘입니다.
    - 또는 `stack` 이라는 자료구조를 이용하여 구현하게 된다.
   ![](img/2024-01-28-22-13-46.png)
  - [예제 코드](./2_2주차/dfs_list.cpp)
  - [기본 문제](./2_2주차/dfs_기본문제1.cpp)
    - connect component 문제임
  
  8. 너비우선탐색(BFS, Breadth First Search)
  - BFS는 가까운 노드를 탐색해 나가면서, 레벨별로 방문하는 알고리즘이다. 노드를 이동하는 비용은 다 같아야 한다. 
    - 같은 가중치를 가진 그래프에서 최단거리 알고리즘으로 쓰임
    - 이동비용이 다르다면, `sort` 정렬 알고리즘이 들어와야함
  ![](img/2024-01-28-22-46-44.png)
  - `Queue` 라는 자료구조를 이용하는 것, 먼저 `candidates`에 추가된 노드를 먼저 방문한다.

  ```c++
  queue<int> q;
  q.push(here);
  searched[here] = 1; // 시작
  while(q.size()){
    int here = q.front();
    q.pop(); // queue에서 꺼낼 때, 방문하는 것
    for(int there: adj[here]){
      if (searched[there] == 0){
        searched[there] = searched[here]+1; // 최단거리 이동경로 정보도 같이 담아줌
        q.push(there);
      }
    }
  }
  ```
  - [예제 코드](./2_2주차/bfs_list.out)
  - [기본 문제](./2_2주차/bfs_기본문제1.cpp)

9. DFS와 BFS의 비교
  - 최악의 조건에서 시간복잡도는 모두 O(V^2)가 되므로 동일함
  - DFS가 메모리를 덜 쓰는 편이고, 코드가 좀 더 짧음(완전탐색 코드)
  - BFS 메모리를 더 쓰는 편이고, 최단거리를 구할 수 있음

10. 트리 순회 (Tree traversal) 후위순회, 전위순회, 중위순회
  - 트리 순회는 트리 구조에서 각각의 노드를 정확히 한번만, 체계적인 방법으로 방문하는 과정
    - 방문 순서에 따라 후위/전위/중위/레벨 순회가 있음
  - [예제 코드](./2_2주차/traversal.cpp)

  1. 후위순회(postorder traversal)
  - 자식들 노드를 방문하고 자신의 노드를 방문하는 것 "자식들부터"
    ![](img/2024-01-28-23-36-11.png)
    ![](img/2024-01-28-23-39-13.png)

  2. 전위순회(preorder traversal)
  - 자신의 노드부터 방문하고 자식 방문하는 것 "나부터"
  - `dfs` 알고리즘이 전위순회 알고리즘이다.
    ![](img/2024-01-28-23-48-52.png)

  3. 중위순회(inorder traversal)
  - 왼쪽 노드를 먼저 방문한다음 자신의 노드를 방문하고 그 다음 오른쪽 노드를 방문한다. "꼈다"
    - "안에 넣다.(in)"
    ![](img/2024-01-28-23-54-27.png)
    ![](img/2024-01-28-23-57-02.png)
    - `4->2->5->1->3`

  4. 레벨순회(level traversal)
  - `bfs`알고리즘이 레벨순회 알고리즘이다.
  - `1->2->3->4->5`

11. 반례를 생각하는 팁(맞왜틀팁)
  - 아래 테스트 케이스를 직접 만들어보고 입력시켜본다.
    1. 최소 조건, 최대 조건
    2. 있을 때/없을 때, 없거나/있거나 조건
  
  - 변수명을 최대한 표준화해서 사용해보자
    - (i,j,k)(배열 인덱스), next_i, next_j, answer(정답), delta(변화량), mx(최대), mn(최소)

- 백준 풀기
  - [boj2178](./2_2주차/boj2178.cpp) // 2-A
    - 문제 자체는 bfs로 뻔한 문제인데, 입력을 받아오는 과정에서 엄청난 시간 소모를 ㅠㅠ...
    - 아래 코드 스니펫(`Code Snipet`)을 잘 익혀두자...
    ```c++
    string s;
    for (int i = 0; i < N; ++i)
    {
      cin >> s;
      for (int j = 0; j < M; ++j)
      {
        // 문자'1'과 숫자1은 다르다. 문자'1'은 아스키코드로 49이다. 1이 아니다.
        maze[i][j] = s[j]-'0'; 
      }
    }
    ```
  - [boj1012](./2_2주차/boj1012.cpp) // 2-B
    - 혼자 풀었음, `Connect Component, Fluid Fill 문제`
  
  - [boj2468](./2_2주차/boj2468.cpp) // 2-C
    - 혼자 풀었음, 문제 오타 있어서 좀 헤맸는데 문제 오타였음 -> 문제 오타가 아님, 내가 틀린거임
      - 아무지역도 물에 잠기지 않을 수 있다.
        - 아무 지역도 잠기지 않으면 안전영역은 1이지 0이 아님
        - 문제에 대한 반례 조건을 잘 따져보자.....

    - 신기한게 제한시간 1초여서, DFS 를 for문 돌리면 3중 루프니까 시간 초과일 수 있겠다 싶어서 h 높이를 찾는 것을 바이너리 서치 알고리즘이라도 적용해야 하는건가 고민했는데,, naive 하게 3중루프 써서 하니까 통과네? ㅎㅎ
      - 시간복잡도 참고:  `보통 1000만 까지는 시간복잡도 발생해도 타임오버 안나나 봄`

  - [boj2583](./2_2주차/boj2583.cpp) // 2-D
    - 혼자 풀었음

  - [boj1992](./2_2주차/boj1992.cpp) // 2-E, 쿼드트리, 다시 풀어보기
    - 풀어보려고 했는데, 1차 시도는 실패임 (24.1/31)
    - 분할정복 이런거 써서 했던것 같고 아주 예전에 답지 참고해서 풀었던 문제같은데.....
      - DFS로 풀면 될 것 같아서, 1시간 이상 풀어봤는데 잘 안되었다...ㅠ [boj1992실패](./2_2주차/boj1992_fail.cpp)
    
    - 풀이 (해설)
      - 재귀함수를 생각해야할 때? 똑같은 로직이 반복되는데, 매개변수는 바뀌어서 처리해야할 때
      - 참고: 분할정복은 재귀함수 아니면 `stack`으로 풀 수 있음
      - [boj1992](./2_2주차/boj1992.cpp)

    - 다시 풀어봐야할 문제다
      - 다음날 다시 풀어봄

  - [boj2828](./2_2주차/boj2828.cpp) // 2-F
    - 혼자 풀기 실패... 문제 독해부터가 난해하네;;
      - 문제 독해 이해를 다시하고 혼자 풀었음 (맞추었음)
      - 생각보다 엄청 쉬운문제인데, 최소값을 구하라는 문제의 말에 BFS 로 풀어야하는문제다라고 생각해버리는 바람에.., 이걸 어떻게 1차원인데 BFS로 묶어서 한번에 풀 수 있는지 고민하다가.. 시간을 엄청 써서 풀었음... 
    - 구현 문제 카테고리에 속하는 쉬운문제인데...


  - [boj2910](./2_2주차/boj2910.cpp) // 2-G
    - 일단 푸는데 좀 걸렸고, tuple을 써야하나 해서,, 근데 tuple 사용법이 익숙치가 않네요 ㅠㅠ
    - 푼것 같은데, 예외 처리 하느라 시간이 더 걸렷고, 제출했더니 메모리 초과 ..

    - 해설
      1. 맵 2개를 써서, 한개는 빈도수를 체크하고, 한개는 처음 숫자가 등장한 idx를 저장함
        - tip: 맵 자료구조는 지역변수라해도 선언과 동시에 0 초기화됨
        - tip: 맵 자료구조는 바로 정렬(sort)함수 사용이 안되니, vector 자료구조에 담아야한다.
        - tip: `mp.first: key`, `mp.second: value`
      2. 다음에 다시 한번 풀어보자

  - [boj4659](./2_2주차/boj4659.cpp) // 2-H
    - 재귀함수로 풀 수 있다는 것을 혼자 잘 떠올려서, 혼자 풀 수 있었음
    - 다만, 구현의 내용이 길고, 그 사이에 인덱싱 같은 기본적인 실수가 많아서,,,, 디버깅하는데 시간이 매우 오래 걸렸다.

  - [boj2870](./2_2주차/boj2870.cpp) // 2-I
    - 혼자 풀었음, 처음에는 out of range 가 나왔는데, 그 이유가 stoi의 출력값 범위를 넘어섰기 때문임
      - 문제를 읽고, 바로 파악해야 하는 제약조건이고, 이걸 캐치해야 로직을 제대로 짤수있음
      - 당연 longlong을 지원하는 `stoll` 도 되지는 않았고, 별수 없이 `string` 으로 데이터를 저장시켜야 했음
    - 간단한 문제인데도 오래 걸리네요...
      1. `string& erase (size_t pos = 0, size_t len = npos);`
        - 리턴받지 않아도 레퍼런스 호출이라 인풋 배열이 변형되서 나오게 됨
      2. `string substr (size_t pos = 0, size_t len = npos) const;`
    - 강의를 들이니까, 필요없는 조건문들은 삭제할 수 있었음

  
  - [boj10709](./2_2주차/boj10709.cpp) // 2-J
    - 무식하게 풀면되는거 아닌가 하다가, DFS도 배운거니까 적용해보자 하니까, 쉽게 풀리는 형태였음 ㅎㅎ
  
  - [boj3474](./2_2주차/boj3474.cpp) // 2-K
    - 혼자 못풀었음... ㅠㅠ..
    - `(2/4 강의는 아직 안들었음)`

  - [boj2852](./2_2주차/boj2852_teacher.cpp) // 2-L
    - 스트링 파싱하는 방법.. 꼭 숙지하자
      ```c++
      istringstream sss(input); // string parsing
      sss >> mm >> delimeter >> ss;
      ```
    - 문제는 구현 문제에 가깝다고 보인다. 그만큼 로직도 간단하지만, 경우의 수를 잘 나누어 실수 없이 구현하는 것이 핵심인듯 싶다.
      - 졸려서 그런거라고 믿고 싶지만,, 꽤 오래 걸렷다 모든 반례에 대한 경우의 수를 따지느라..
    - 분, 초 이렇게 문제가 주어지면, 초를 기반으로 단위를 정렬하고 풀어라.
    - [내가 푼 코드](./2_2주차/boj2852_my.cpp)
      1. 구현 문제를 만나면, 함수를 많이 짜서 코드를 최대한 간결하게 유지할 수 있도록
      2. 코드가 길어지면, 실수가 잦고, 생각도 굳는다 ㅠ
